<!--
 * @Author: Jeason 19938943480@163.com
 * @Date: 2023-08-02 09:55:49
 * @LastEditors: Jeason 19938943480@163.com
 * @LastEditTime: 2023-08-02 09:56:05
 * @FilePath: \undefinedc:\Users\User\Desktop\NoteBook\Thread.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 一、线程、进程
## 1.1 进程与线程的概念
**进程代表的是正在运行的应用程序，线程则是进程中的一个单元，负责当前进程中程序的执行**。  
如下，任务管理器界面就是进程  
![image](https://github.com/xuehao-in-studing/MultiThread/assets/102791379/76d9dca2-0f8c-4886-9eb9-12a29fc1797a)  
详细信息界面就可以表示线程，chorme是一个应用程序，但是有多个线程在执行。  
![image](https://github.com/xuehao-in-studing/MultiThread/assets/102791379/bec1661b-bcd2-4189-a38b-ce8bf777e3ff)  
对于单核CPU来说，不能够真正地实现多线程，因为一个核同时只能执行一个程序，在多线程之间切换只是并发；而多核CPU可以同时执行多个程序，真正做到了多线程并行。

## 1.2 进程与线程的区别
**进程有自己独立的代码和数据空间，切换进程会有较大的开销，一个进程包含1-n个线程**  

**线程共享代码、数据和地址空间，每个线程有自己独立的栈和程序计数器，保证每个线程之间的控制逻辑是独立的。切换线程开销小**  

**真正的多线程并发**：  
  t1线程执行t1的程序，t2线程执行t2的程序，互不干扰。 

## 1.3 进程的生命周期
简单来说，如果进程文件被执行，从硬盘放到了内存中，如下面这张图所示。
![image](https://github.com/xuehao-in-studing/MultiThread/assets/102791379/df8934a7-4b75-4a2c-82cc-0c9217f1148c)
但是进程如果阻塞，会占用内存，此时操作系统通常会把阻塞的进程再次放到硬盘当中，此时进程处于了**挂起状态**，等待被调用到内存当中
![image](https://github.com/xuehao-in-studing/MultiThread/assets/102791379/811cfdd0-bd02-4f36-b362-b03e3d43f2a3)
注：**阻塞状态是指进程等待某个事件的发生**，例如输入输出(I/O)操作，这时即便CPU调用它，他也不能运行

## 1.4 进程的上下文切换
此外，如图中进程状态的切换也称为进程的上下文切换，当发生切换时，是操作系统的内核来进行管理和调度。进程切换时，会保存当前进程的虚拟内存、栈、全局变量等用户空间的资源，还有内核堆栈、寄存器等内核空间的资源。待被调度时，内核再将这些信息恢复。  

但是线程切换消耗内存、内核资源，要尽量减少进程的上下文切换。  
常见的上下文切换场景：
- CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。
- 进程在系统资源不足（比如内存不足）时，进程挂起。
- sleep主动挂起
- 优先级更高的进程抢占
- 硬件中断

# 二、线程对象
## 2.1 线程对象的生命周期
- 新建状态
- 就绪状态
- 运行状态
- 阻塞状态
- 死亡状态  

可以从下面这张图理解：  
<div align="center">
    <img src="https://github.com/xuehao-in-studing/MultiThread/assets/102791379/91be7607-212f-4fea-959b-dfee040a398c" alt="线程状态">
</div>  

- 就绪状态：线程对象创建以后，调用了start方法，进入线程池，等待CPU调用。  
- 运行状态：线程正在被执行。  
- 阻塞状态：阻塞状态是线程因为某种原因放弃CPU的的使用权，暂停运行。  
- 结束状态：abort方法(及其不推荐使用，因为会直接杀死线程，导致数据丢失或者系统崩溃)，采用终止标志位等方法。 

阻塞状态分为三种：  
- 等待阻塞:运行的线程调用wait方法，把线程放入等待池，wait会释放持有的锁。  
- 同步阻塞：运行的线程在获取对象的同步锁时，若同步锁被别的线程占用，则该线程会被放到线程池当中。  
- 其他阻塞：运行的线程调用sleep或者join方法或者发出IO请求时，线程会被设置为阻塞状态。当sleep超时、join等待线程终止或者IO处理完毕，线程重新就绪。    
 

## 2.2 常用方法解析
- sleep(millisecond)，当前线程休眠一定时间，暂停执行。
- join(),该方法启动后直接调用，是一种**线程保护机制**。
  - 表示**所有线程必须等待该线程结束才能继续被调用**，也就是join后的代码必须等待这个线程结束才能执行。
  - 举例说明：可能main主程序当中需要调用其他线程的变量，如果不加join，可能在线程没有执行完毕的时候main就进行了调用，得到错误的结果。
- yield(),暂停当前执行的线程对象，并转而执行其他线程。**让当前线程回到就绪的状态，给其他相同优先级的线程被执行的机会**。
- sleep与yield的区别：sleep使让当前线程休眠，这段时间内一定不会再次执行该线程，而yield则是让当前线程退让，但还是有可能从线程池中被提取并执行。

## 2.3 前台线程与后台线程：
前台线程是指运行在前台，必须前台线程结束后主线程才能结束。后台线程则是运行在后台的线程，当应用程序主线程退出时自动结束的一种线程。  
c#中使用使用 Thread.IsBackground设置线程是否为后台线程。  

注1：调用thread.start方法时，并不是说线程就开始执行了，而是线程进入了就绪状态，何时调用由操作系统决定。  

注2：线程的使用涉及到栈，start相当于开了一个分支栈去调用方法，main则是在主栈。详见[这里](https://blog.csdn.net/qq_44715943/article/details/116714584?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168760936816800215066542%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168760936816800215066542&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116714584-null-null.142^v88^control,239^v2^insert_chatgpt&utm_term=%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4187)  


## 2.4 多线程冲突
线程的冲突：当一个共享变量已经在线程内部发生了改变，但还没有写入寄存器，在写入寄存器之前，另外一个线程就对该共享变量进行调用，那么调用到的变量还是没有改变之前的变量，那么会造成变量的错误调用与修改，这种现象也叫做竞争条件。  

**互斥：**  
这个时候我们就希望线程之间是互斥的，也就是线程在临界区执行时，其他线程不能进入临界区。  

**同步：**
同步就是多个线程在关键节点能够互相通信或者制约。  
例如：操作A应该在B之前执行，操作C应该在A和B都完成之后执行。就像女儿饿了，喊妈妈做饭，女儿只有等待妈妈做完饭并通知之后才能吃饭。  

为了实现线程之间的正确协作，就必须提供实现进程协作的方法，主要有
：  
- 锁：加锁解锁
- 信号量：P、V操作

## 2.5 锁
锁的概念就是要保护线程之间的共享资源，防止线程之间造成资源的浪费和挤兑和上述提到的竞争条件。  
### 2.5.1 自旋锁
当A线程持有锁时，如果B线程想去访问锁里面的共享资源，但是访问不到时，会一直循环(自璇)，一直等到CPU可用。


